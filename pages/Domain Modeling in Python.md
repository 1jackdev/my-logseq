- Encapsulating behavior by using abstractions is a powerful tool for making code more expressive, more testable, and easier to maintain.
- Layering
	- Presentation Layer -> Business Logic -> Database Layer
- Dependency Inversion Principle
	- High-level modules should not depend on low-level modules. Both should depend on abstractions.
	- Abstractions should not depend on details. Instead, details should depend on abstractions.
	- "Depends on" does not necessarily mean *imports* or *calls*. It just means that one module knows about or needs another module
		- at sennder, the splitting module (creating documents) should not *depend on* the s3 client. Both should depend on abstractions.
- High-level Modules
	- code that our organization really cares about
		- at sennder, this is the code that creates and updates domain entities (SP, CC, fin docs)
	- functions, classes, packages that deal with real-world concepts
	- Should be easy to change as business needs change. We donâ€™t want business logic changes to slow down because they are closely coupled to low-level infrastructure details.
- Low-level Modules
	- code that our organization really DOES NOT care about
		- at sennder, this is the s3 client, launch darkly, whether we use lambda or http or kafka
	- Should be easy to change without needing to change business logic.
		- at sennder, if sqlalchemy becomes deprecated for some reason, we shouldn't need to change business logic.
	-
-
- References
	- [[Message Bus Dynamic Docs]]